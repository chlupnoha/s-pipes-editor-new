# baseURI: http://topbraid.org/sparqlmotionlib-core
# imports: http://spinrdf.org/spif
# imports: http://spinrdf.org/spr
# imports: http://topbraid.org/sparqlmotion
# imports: http://www.topbraid.org/2007/05/composite.owl

@prefix composite: <http://www.topbraid.org/2007/05/composite.owl#> .
@prefix owl: <http://www.w3.org/2002/07/owl#> .
@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#> .
@prefix sm: <http://topbraid.org/sparqlmotion#> .
@prefix sml: <http://topbraid.org/sparqlmotionlib#> .
@prefix spin: <http://spinrdf.org/spin#> .
@prefix spl: <http://spinrdf.org/spl#> .
@prefix xsd: <http://www.w3.org/2001/XMLSchema#> .

spl:Argument
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate sml:hidden ;
      spl:valueType xsd:boolean ;
      rdfs:comment "Indicates whether this is a \"hidden\" argument. Hidden arguments will not be presented to the user in input dialogs but instead always have their defaultValue."^^xsd:string ;
    ] ;
.
sml:AppendText
  rdf:type sm:Module ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:defaultValue "text"^^xsd:string ;
      spl:predicate sml:variable ;
      spl:valueType xsd:string ;
      rdfs:comment "The name of the variable to append to."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sml:template ;
      spl:valueType xsd:string ;
      rdfs:comment "The (template) string to append to the variable value."^^xsd:string ;
    ] ;
  rdfs:comment "Appends a given text (possibly containing template expressions, sml:template) to the value of a given variable (sml:variable) and binds the concatenation of the old value plus the new text to the same variable. This can be used to incrementally build up a string."^^xsd:string ;
  rdfs:label "Append text"^^xsd:string ;
  rdfs:subClassOf sml:TextProcessingModules ;
.
sml:ApplyConstruct
  rdf:type sm:Module ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate sml:replace ;
      rdfs:comment "If set to true, the output triples will only contain the constructed triples. If no values or false are specified, the output will be the union of the input triples and the constructed triples."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Attribute ;
      spl:minCount 1 ;
      spl:predicate sml:constructQuery ;
      rdfs:comment "The SPARQL Construct queries that deliver the triples that shall be added."^^xsd:string ;
    ] ;
  rdfs:comment "Runs one or more SPARQL Construct queries on the input triples. The output RDF will consist of the constructed triples and (unless sml:replace is true) the input triples." ;
  rdfs:label "Apply Construct"^^xsd:string ;
  rdfs:subClassOf sml:RDFProcessingModules ;
.
sml:ApplyResourceConstructors
  rdf:type sm:Module ;
  rdfs:comment "Executes all spin:constructors for the instances in the input graph, and returns the union of the constructed triples and the input graph."^^xsd:string ;
  rdfs:label "Apply resource constructors"^^xsd:string ;
  rdfs:subClassOf sml:RDFProcessingModules ;
.
sml:ApplyTopSPIN
  rdf:type sm:Module ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:defaultValue spin:rule ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate sml:predicate ;
      spl:valueType rdf:Property ;
      rdfs:comment "The predicate to get the rules from. Usually spin:rule, but can be any SPIN property (subPropertyOf spin:query)"^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate sml:flatten ;
      spl:valueType xsd:boolean ;
      rdfs:comment "If set to true, the engine will copy all input triples into a single in-memory graph, and then operate on that (faster) graph. In some cases, this option has improved performance by a factor of 8. Note that this option may not make sense if one of the input graphs is a (large) database. Setting this option to true will also lead to ignore the value of sml:replace, and only the flattened graph will be forwarded into the next steps of the script (i.e. sml:replace=true)."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate sml:replace ;
      spl:valueType xsd:boolean ;
      rdfs:comment "Specifies whether the resulting inferred triples shall replace the input. If false, the union of inferred triples and old triples are returned. Note that this flag is not supported if sml:flatten = true."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate sml:singlePass ;
      spl:valueType xsd:boolean ;
      rdfs:comment "Specifies whether only a single pass over all rules shall be made. By default (false), TopSPIN will iterate until no further inferences have been made."^^xsd:string ;
    ] ;
  rdfs:comment "Applies the TopSPIN rules inference engine on the input graph. This assumes that the input graph contains one or more SPIN rules (stored using the property specified under sml:predicate, which defaults to spin:rule)."^^xsd:string ;
  rdfs:label "Apply TopSPIN" ;
  rdfs:subClassOf sml:RDFProcessingModules ;
.
sml:AssertTrue
  rdf:type sm:Module ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate sml:text ;
      spl:valueType xsd:string ;
      rdfs:comment "the error message"^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Attribute ;
      spl:maxCount 1 ;
      spl:minCount 1 ;
      spl:predicate sml:askQuery ;
      spl:valueType <http://spinrdf.org/sp#Ask> ;
      rdfs:comment "The ASK query that must return true."^^xsd:string ;
    ] ;
  rdfs:comment "Evaluates an ASK condition and stops the execution of the script and reports an error if the condition is false. This module is particularly useful for web services that simply cannot execute if unexpected situations are encountered. The module will simply pass through all variable bindings and RDF triples if no errors are found." ;
  rdfs:label "Assert true"^^xsd:string ;
  rdfs:subClassOf sml:ControlFlowModules ;
.
sml:BindBySelect
  rdf:type sm:Module ;
  spin:constraint [
      rdf:type spl:Attribute ;
      spl:maxCount 1 ;
      spl:minCount 1 ;
      spl:predicate sml:selectQuery ;
      rdfs:comment "A SPARQL Select query that is executed over the input triples. The result variables of the first result row will be bound in the succeeding modules."^^xsd:string ;
    ] ;
  rdfs:comment "Runs a SPARQL select query and binds all result variables of the first matching result set. The input RDF is simply passed through to the next module. For example, if you run SELECT ?name ?age WHERE { my:Person my:name ?name ; my:age ?age } then the variables name and age will be bound as output variables." ;
  rdfs:label "Bind by select"^^xsd:string ;
  rdfs:subClassOf sml:ControlFlowModules ;
.
sml:BindLiteralVariable
  rdf:type sm:Module ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:defaultValue xsd:string ;
      spl:predicate sml:datatype ;
      spl:valueType rdfs:Datatype ;
      rdfs:comment "The target datatype, e.g. xsd:string or xsd:int. Default: xsd:string."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sm:outputVariable ;
      rdfs:comment "The name of the output variable."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sml:template ;
      rdfs:comment "the template string"^^xsd:string ;
    ] ;
  rdfs:comment "Binds the output variable with a constant of a given datatype, or with a value derived from one or more other input variable values. The template could be as simple as {?varName} to insert the variable's value or more complex such as {?firstName} {?lastName}. This module can also be used to convert the datatype, e.g. to convert a xsd:string into a xsd:float." ;
  rdfs:label "Bind literal variable"^^xsd:string ;
  rdfs:subClassOf sml:ControlFlowModules ;
.
sml:BindWithConstant
  rdf:type sm:Module ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:defaultValue "text" ;
      spl:predicate sm:outputVariable ;
      rdfs:comment "The name of the variable that will hold the constant. Default: text."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sml:value ;
      rdfs:comment "The constant value (either a resource or a literal)."^^xsd:string ;
    ] ;
  rdfs:comment "Binds a variable with a given RDF node." ;
  rdfs:label "Bind with constant"^^xsd:string ;
  rdfs:subClassOf sml:ControlFlowModules ;
.
sml:BranchByAsk
  rdf:type sm:Module ;
  spin:constraint [
      rdf:type spl:Attribute ;
      spl:maxCount 1 ;
      spl:minCount 0 ;
      spl:predicate sm:else ;
      rdfs:comment "The start of the child script that shall be executed if the ask query evaluates to false."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Attribute ;
      spl:maxCount 1 ;
      spl:minCount 0 ;
      spl:predicate sm:if ;
      rdfs:comment "The start of the child script that shall be executed if the ask query evaluates to true."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Attribute ;
      spl:maxCount 1 ;
      spl:minCount 1 ;
      spl:predicate sml:askQuery ;
      rdfs:comment "The SPARQL Ask query that delivers true (sm:if) or false (sm:else) to determine the branching condition."^^xsd:string ;
    ] ;
  rdfs:comment "Runs a SPARQL Ask query and, depending on the resulting boolean, either continues with the sm:if or the sm:else branch. Both branches can be sub-scripts, and the sm:if and sm:else should point to the entry points of those sub-scripts. Those entry modules will be passed the same RDF triples and variable bindings as passed to theBranchByAsk module itself. The result of the execution will be the target module (last module in the sub-script) of the selected branch. All variable bindings of the result module will also be passed on as output to the next module(s). Both branches must have exactly one target module. If a branch is empty then the module's input will be passed on unchanged."^^xsd:string ;
  rdfs:label "Branch by ask"^^xsd:string ;
  rdfs:subClassOf sml:ControlFlowModules ;
.
sml:CatchExceptions
  rdf:type sm:Module ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:defaultValue "error"^^xsd:string ;
      spl:predicate sm:outputVariable ;
      spl:valueType xsd:string ;
      rdfs:comment "The name of the output variable that shall hold the error message."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate sml:stackTraceVariable ;
      spl:valueType xsd:string ;
      rdfs:comment "The name of a variable that shall contain the full stack trace."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Attribute ;
      spl:maxCount 1 ;
      spl:minCount 1 ;
      spl:predicate sm:body ;
      spl:valueType sm:Modules ;
      rdfs:comment "The head of the script to execute. Must have a single end module."^^xsd:string ;
    ] ;
  rdfs:comment "Runs a sub-script (sm:body) and catches any errors (Java Exceptions) that happened within it. Normally, the SPARQLMotion engine exits on hitting any Exception, but this module provides a level of error handling. If an error occurs, then the result variable (sm:outputVariable) will contain the error message, and the result graph will be the same as the input of the module itself. Otherwise, the output graph will be the last module of the nested body script, and any variable bindings from the body will be applied to the next modules. As an option, the full stack trace can be bound to a variable as well."^^xsd:string ;
  rdfs:label "Catch exceptions"^^xsd:string ;
  rdfs:subClassOf sml:ControlFlowModules ;
.
sml:CheckConstraints
  rdf:type sm:Module ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate sml:selectQuery ;
      spl:valueType <http://spinrdf.org/sp#Select> ;
      rdfs:comment "An (optional) SPARQL SELECT query that delivers the resources that shall be checked."^^xsd:string ;
    ] ;
  rdfs:comment "Runs all SPIN constraints defined in the current input graph. The output of this module will be a new RDF graph that only contains the spin:ConstraintViolation instances. If the SELECT query is specified, then only the selected resources will be checked, not the whole model."^^xsd:string ;
  rdfs:label "Check constraints"^^xsd:string ;
  rdfs:subClassOf sml:RDFProcessingModules ;
.
sml:CloneVariable
  rdf:type sm:Module ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sm:outputVariable ;
      spl:valueType xsd:string ;
      rdfs:comment "The name of the output variable that will be created."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sml:inputVariable ;
      spl:valueType xsd:string ;
      rdfs:comment "The name of the input variable that shall be cloned."^^xsd:string ;
    ] ;
  rdfs:comment """Clones a given variable value and assigns it to a new output variable. The input variable will keep its value.

This module can be useful to \"rename\" an existing variable so that it has a matching name that is expected by modules downstream in the script. For example, if you have a variable ?xmlFile but a next module expects an input argument ?xml (via an argument sml:xml), then you can use sml:CloneVariable to bind ?xml with the value of ?xmlFile. Note that in many (most?) cases, you can achieve the same by using inline SPARQL expressions: in TBC use \"Add SPARQL expression\" from the context menu of the property name and enter an expression such as ?xmlFile at the sml:xml property."""^^xsd:string ;
  rdfs:label "Clone variable"^^xsd:string ;
  rdfs:subClassOf sml:ControlFlowModules ;
.
sml:ConcatenateText
  rdf:type sm:Module ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:defaultValue "text" ;
      spl:predicate sm:outputVariable ;
      rdfs:comment "The name of the output variable that will contain the concatenated text string. Default: text."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate sml:separator ;
      rdfs:comment "An optional separator that will be inserted between the text units."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sml:selectQuery ;
      spl:valueType <http://spinrdf.org/sp#Select> ;
      rdfs:comment "The SPARQL Select query that will deliver the individual values that shall be concatenated."^^xsd:string ;
    ] ;
  rdfs:comment "Executes a SPARQL Select query and creates a single long text string by concatenating all result variable bindings. This can be used, for example, to create a single \"fullName\" value from \"firstName\" and \"lastName\" properties (in which case the order of variables in the SELECT clause is relevant. Another use case is to build a single long string from multiple property values of the same kind, e.g. to concatenate all text bodies of all RSS items in a newsfeed. The resulting text can then be further processed by text processing modules such as text miners." ;
  rdfs:label "Concatenate text"^^xsd:string ;
  rdfs:subClassOf sml:TextProcessingModules ;
.
sml:ConstructNTFile
  rdf:type sm:Module ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate sml:replace ;
      spl:valueType xsd:boolean ;
      rdfs:comment "True to overwrite the NT file. False to append."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sml:targetFilePath ;
      spl:valueType xsd:string ;
      rdfs:comment "The path to the target file path."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Attribute ;
      spl:minCount 1 ;
      spl:predicate sml:constructQuery ;
      rdfs:comment "The SPARQL Construct queries that deliver the triples that shall be added."^^xsd:string ;
    ] ;
  rdfs:comment "Executes a CONSTRUCT query in a streaming fashion and writes all resulting triples into a given N-Triples file. The resulting file can then be used as input to databases, e.g. using the TDB import wizard of TopBraid Composer. This module has a smaller memory foot-print than sml:ApplyConstruct, in which all constructed triples need to fit into memory."^^xsd:string ;
  rdfs:label "Construct NT file"^^xsd:string ;
  rdfs:subClassOf sml:ExportToLocalModules ;
.
sml:ControlFlowModules
  rdf:type sm:Module ;
  spin:abstract "true"^^xsd:boolean ;
  rdfs:label "Control Flow"^^xsd:string ;
  rdfs:subClassOf sml:ProcessingModules ;
.
sml:ConvertStringToSPINRDF
  rdf:type sm:Module ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate sml:uri ;
      rdfs:comment "the URI of the query to create (either xsd:string or resource)"^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sml:text ;
      spl:valueType xsd:string ;
      rdfs:comment "the SPARQL query in textual form; with or without namespace prefixes"^^xsd:string ;
    ] ;
  rdfs:comment "Converts a SPARQL query (in textual form) to a SPIN RDF syntax resource. The resulting output graph will contain exactly the triples of the SPIN query. These triples can then be used, for example, to analyze the structure of a SPARQL query dynamically. The inverse operation can be achieved using the SPARQL function smf:convertSPINRDFToString."^^xsd:string ;
  rdfs:label "Convert string to SPIN RDF"^^xsd:string ;
  rdfs:subClassOf sml:TextProcessingModules ;
.
sml:ConvertTextToRDF
  rdf:type sm:Module ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:defaultValue sml:Turtle ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate sml:serialization ;
      spl:valueType sml:RDFSerialization ;
      rdfs:comment "The (optional) serialization format, e.g. XML, Turtle or NTriple. Default: Turtle."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sml:text ;
      rdfs:comment "The text to parse."^^xsd:string ;
    ] ;
  rdfs:comment "Converts a text in one of the RDF serializations into an RDF graph. In a typical scenario, the text would be passed into the script as external (web service) input. The result of this module is the input RDF triples plus the parsed triples."^^xsd:string ;
  rdfs:label "Convert text to RDF"^^xsd:string ;
  rdfs:subClassOf sml:TextProcessingModules ;
.
sml:ConvertTextToRDFList
  rdf:type sm:Module ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:defaultValue "list"^^xsd:string ;
      spl:predicate sm:outputVariable ;
      spl:valueType xsd:string ;
      rdfs:comment "the name of the output variable that will contain the rdf:List"^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sml:text ;
      spl:valueType xsd:string ;
      rdfs:comment "the comma-separated list of URIs"^^xsd:string ;
    ] ;
  rdfs:comment """Takes a comma-separated list of URIs as input and creates an rdf:List from it which is then visible to all modules downstream. The rdf:List will be a blank node (or rdf:nil) and the provided output variable will point to it. Note that the RDF output of this module consists of the rdf:List triples only, i.e. the input triples are not passed through.
Among others, this module can be used by web services that take lists as input.""" ;
  rdfs:label "Convert text to RDFList"^^xsd:string ;
  rdfs:subClassOf sml:TextProcessingModules ;
.
sml:ConvertXMLToRDF
  rdf:type sm:Module ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate sml:replace ;
      spl:valueType xsd:boolean ;
      rdfs:comment "If true then the resulting output graph will not include the input graph, i.e. only the new triples will be returned."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sml:baseURI ;
      rdfs:comment "The base URI of the new RDF (for the creation of the new class and property names)."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sml:xml ;
      rdfs:comment "The XML document that shall be converted to RDF. To avoid character encoding issues, we strongly recommend this value to be a reference to an already parsed XML document, and not a literal. In other words, use \"Add SPARQL expression\" from the drop down menu and enter ?varName and do not use a string value such as {?varName}. The actual document parsing should be handled by predecessing modules such as sml:ImportXMLFromURL."^^xsd:string ;
    ] ;
  rdfs:comment "Converts an arbitrary XML input document into an RDF graph using the Semantic XML mapping approach. The input graph of this module may contain class definitions that have sxml: declarations attached to them and these will be used for the instances. For more, see Help > Import and Export > Creating, Importing, Querying, Saving XML documents with Semantic XML."^^xsd:string ;
  rdfs:label "Convert XML to RDF"^^xsd:string ;
  rdfs:seeAlso <http://composing-the-semantic-web.blogspot.com/2007/11/xmap-mapping-arbitrary-xml-documents-to.html> ;
  rdfs:subClassOf sml:XMLProcessingModules ;
.
sml:CopyFile
  rdf:type sm:Module ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sml:newFilePath ;
      spl:valueType xsd:string ;
      rdfs:comment "The path for the target file."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sml:oldFilePath ;
      spl:valueType xsd:string ;
      rdfs:comment "The path to the source file."^^xsd:string ;
    ] ;
  rdfs:comment "Creates a copy of a given file within the workspace."^^xsd:string ;
  rdfs:label "Copy file"^^xsd:string ;
  rdfs:subClassOf sml:FileProcessingModules ;
.
sml:CreateMatrix
  rdf:type sm:Module ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:defaultValue "text" ;
      spl:predicate sm:outputVariable ;
      rdfs:comment "The variable that will contain the resulting matrix as an xsd:string literal. Default: text."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Attribute ;
      spl:maxCount 1 ;
      spl:minCount 1 ;
      spl:predicate sml:cellQuery ;
      rdfs:comment "A SPARQL Select query that is executed for each cell in the matrix. The query should reference the result variables of column and row queries (these will be bound automatically by the engine)."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Attribute ;
      spl:maxCount 1 ;
      spl:minCount 1 ;
      spl:predicate sml:columnQuery ;
      rdfs:comment "A SPARQL Select query that delivers the resources or literals that define the columns. The query should have a single result variable, and this variable should be used in the cell query."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Attribute ;
      spl:maxCount 1 ;
      spl:minCount 1 ;
      spl:predicate sml:rowQuery ;
      rdfs:comment "A SPARQL Select query that delivers the resources or literals that define the rows. The query should have a single result variable, and this variable should be used in the cell query."^^xsd:string ;
    ] ;
  rdfs:comment """Creates a matrix (spreadsheet) and binds it as a text value to a given output variable.

The rows and columns of the matrix are specified by two SPARQL queries. These queries must deliver variable bindings to enumerate the resources that shall be used as rows and columns. The cell values are then computed using a third query (cellQuery) that should reference the bound variable names from the row and column queries.""" ;
  rdfs:label "Create matrix"^^xsd:string ;
  rdfs:subClassOf sml:TextProcessingModules ;
.
sml:CreateSPINResultSet
  rdf:type sm:Module ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:defaultValue "table"^^xsd:string ;
      spl:predicate sm:outputVariable ;
      spl:valueType xsd:string ;
      rdfs:comment "The name of the output variable that will point to the new spr:Table resource."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sml:selectQuery ;
      rdfs:comment "The SELECT query to evaluate."^^xsd:string ;
    ] ;
  rdfs:comment "Converts the result set of a given SPARQL SELECT query (sml:selectQuery) to an SPIN result set (SPR table resource). The resulting resource can then be queried using the SPR functions. The output graph of this module contains only table triples."^^xsd:string ;
  rdfs:label "Create SPIN Result Set"^^xsd:string ;
  rdfs:seeAlso <http://spinrdf.org/spr.html> ;
  rdfs:subClassOf sml:RDFProcessingModules ;
.
sml:CreateSWPDocument
  rdf:type sm:Module ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:defaultValue "doc"^^xsd:string ;
      spl:predicate sm:outputVariable ;
      spl:valueType xsd:string ;
      rdfs:comment "The name of the output variable that will contain the resulting document (as a string)."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate sml:snippet ;
      spl:valueType xsd:boolean ;
      rdfs:comment "True to only create a UISPIN snippet, e.g. without head/body."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sml:view ;
      spl:valueType <http://uispin.org/ui#Node> ;
      rdfs:comment "The UISPIN snippet to evaluate."^^xsd:string ;
    ] ;
  rdfs:comment """Evaluates a given SWP document (sml:view) and assigns the resulting document to a given string variable (sm:outputVariable). The new variable can then be saved to a file or processed otherwise. All incoming variables of this SM module will be bound in the SWP expression.

Note that in order to insert an SWP view for a given resource (using ui:instanceView etc), you can use the snippet <ui:resourceView ui:resource=\"{= ?varName }\" />.

Also note that in order to use HTML or SVG tags in the sml:view, you will need to import the html.ttl or svg.ttl from the SWP ontologies into the script."""^^xsd:string ;
  rdfs:label "Create SWP document"^^xsd:string ;
  rdfs:subClassOf sml:TextProcessingModules ;
.
sml:CreateSpreadsheet
  rdf:type sm:Module ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:defaultValue "text" ;
      spl:predicate sm:outputVariable ;
      rdfs:comment "The name of the variable that will hold the resulting spreadsheet string. Default: text."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate sml:separator ;
      spl:valueType xsd:string ;
      rdfs:comment "The separator between each column. Default is the tab character, but a typical alternative is \",\"."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sml:selectQuery ;
      spl:valueType <http://spinrdf.org/sp#Select> ;
      rdfs:comment "The SPARQL Select query that delivers the rows of the spreadsheet. The columns will be the result variables of the query."^^xsd:string ;
    ] ;
  rdfs:comment "Creates a spreadsheet text from all bindings of a SPARQL SELECT query. The resulting text will be bound to a variable and can then be saved to a file or further processed."^^xsd:string ;
  rdfs:label "Create spreadsheet"^^xsd:string ;
  rdfs:subClassOf sml:TextProcessingModules ;
.
sml:CreateUISPINDocument
  rdf:type sm:Module ;
  rdf:type owl:DeprecatedClass ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:defaultValue "doc"^^xsd:string ;
      spl:predicate sm:outputVariable ;
      spl:valueType xsd:string ;
      rdfs:comment "The name of the output variable that will contain the resulting document (as a string)."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate sml:snippet ;
      spl:valueType xsd:boolean ;
      rdfs:comment "True to only create a UISPIN snippet, e.g. without head/body."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sml:view ;
      spl:valueType <http://uispin.org/ui#Node> ;
      rdfs:comment "The UISPIN snippet to evaluate."^^xsd:string ;
    ] ;
  rdfs:comment "Deprecated: use sml:CreateSWPDocument instead."^^xsd:string ;
  rdfs:label "Create UISPIN document"^^xsd:string ;
  rdfs:subClassOf sml:TextProcessingModules ;
.
sml:DeleteFile
  rdf:type sm:Module ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sml:filePath ;
      spl:valueType xsd:string ;
      rdfs:comment "The file to delete."^^xsd:string ;
    ] ;
  rdfs:label "Delete file"^^xsd:string ;
  rdfs:subClassOf sml:FileProcessingModules ;
.
sml:ExportModules
  rdf:type sm:Module ;
  spin:abstract "true"^^xsd:boolean ;
  composite:index "2"^^xsd:int ;
  rdfs:comment "Modules that create some output, such as files or UI components." ;
  rdfs:label "Export"^^xsd:string ;
  rdfs:subClassOf sm:Modules ;
.
sml:ExportToLocalModules
  rdf:type sm:Module ;
  spin:abstract "true"^^xsd:boolean ;
  rdfs:label "Export to Local"^^xsd:string ;
  rdfs:subClassOf sml:ExportModules ;
.
sml:ExportToRDFFile
  rdf:type sm:Module ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate sml:targetFilePath ;
      rdfs:comment "The path of the file to create. The path can be relative to the current script's folder (e.g., myFolder/test.rdf) or absolute to the workspace root /myProject/myFolder/test.rdf. Can be left blank if the base URI already has a representation in the workspace. In that case, the primary file in the workspace will be overwritten."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sml:baseURI ;
      rdfs:comment "The base URI under which the resulting file will be registered in the workspace."^^xsd:string ;
    ] ;
  rdfs:comment """Creates a new RDF file at the specified path inside the workspace and with the specified base URI. The serialization is derived from the file name according to TopBraid's conventions, e.g. files ending with .ttl will be written in Turtle format.

Note that if an existing file is overwritten (with matching base URI), and the graph of this file has already been loaded, then the system will not reload the new graph. I.e. if the URI specified in sml:baseURI is the same baseURI of a graph currently open in TBC or TBL, the old graph will remain open and the export will only have an effect after closing the other copies.  A consequence of this is that you cannot overwrite a file and reload its new content within the same session, e.g. sml:ImportRDFFromWorkspace will still deliver the old graph. In order to modify an existing graph, the recommended approach is to use sml:PerformUpdate."""^^xsd:string ;
  rdfs:label "Export to RDF file"^^xsd:string ;
  rdfs:subClassOf sml:ExportToLocalModules ;
.
sml:ExportToRemoteModules
  rdf:type sm:Module ;
  spin:abstract "true"^^xsd:boolean ;
  rdfs:label "Export to Remote"^^xsd:string ;
  rdfs:subClassOf sml:ExportModules ;
.
sml:ExportToTextFile
  rdf:type sm:Module ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate sml:encoding ;
      spl:valueType xsd:string ;
      rdfs:comment "The file encoding such as UTF-8. If left blank, then the platform's default encoding will be used."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate sml:replace ;
      spl:valueType xsd:boolean ;
      rdfs:comment "Specifies whether this will overwrite a file with the same name (true) or whether it will append to an existing file (false)."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sml:targetFilePath ;
      rdfs:comment "The path to the file that shall be created. The path can be relative to the current script's folder (e.g., myFolder/test.txt) or absolute to the workspace root /myProject/myFolder/test.txt."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sml:text ;
      rdfs:comment "The text that shall be written into the file."^^xsd:string ;
    ] ;
  rdfs:comment "Saves text to a file. The text must be the value of the specified input variable." ;
  rdfs:label "Export to text file"^^xsd:string ;
  rdfs:subClassOf sml:ExportToLocalModules ;
.
sml:ExportToXMLFile
  rdf:type sm:Module ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sml:targetFilePath ;
      rdfs:comment "The path to the output file. The path can be relative to the current script's folder (e.g., myFolder/test.xml) or absolute to the workspace root /myProject/myFolder/test.xml."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sml:xml ;
      rdfs:comment "The XML document that shall be written to the file."^^xsd:string ;
    ] ;
  rdfs:comment "Creates an XML file from the value of the input variable." ;
  rdfs:label "Export to XML file"^^xsd:string ;
  rdfs:subClassOf sml:ExportToLocalModules ;
.
sml:FileProcessingModules
  rdf:type sm:Module ;
  spin:abstract "true"^^xsd:boolean ;
  rdfs:label "File Processing"^^xsd:string ;
  rdfs:subClassOf sml:ProcessingModules ;
.
sml:FilterByConstruct
  rdf:type sm:Module ;
  spin:constraint [
      rdf:type spl:Attribute ;
      spl:minCount "1"^^xsd:int ;
      spl:predicate sml:constructQuery ;
      rdfs:comment "A SPARQL Construct query delivering the triples that shall be dropped."^^xsd:string ;
    ] ;
  rdfs:comment "Uses SPARQL CONSTRUCT queries to enumerate triples that shall be dropped from the input triple stream. The output triples of this module contain all input triples except those enumerated by the construct query. For example, if you want to drop all rdfs:comment triples from the input graph, then use a query such as CONSTRUCT {?s rdfs:comment ?o} WHERE {?s rdfs:comment ?o}." ;
  rdfs:label "Filter by construct"^^xsd:string ;
  rdfs:subClassOf sml:RDFProcessingModules ;
.
sml:ImportFileFromURL
  rdf:type sm:Module ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sml:targetFilePath ;
      spl:valueType xsd:string ;
      rdfs:comment "The path the file will be downloaded to"^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sml:url ;
      spl:valueType xsd:string ;
      rdfs:comment "The URL to download the file from"^^xsd:string ;
    ] ;
  rdfs:comment "Downloads any file from a given URL and saves it to a location indicated by the targetFilePath argument. The destination directory is created if it does not exist. If the destination file exists, then this method will overwrite it."^^xsd:string ;
  rdfs:label "Import file from URL"^^xsd:string ;
  rdfs:subClassOf sml:ImportFromRemoteModules ;
.
sml:ImportFromLocalModules
  rdf:type sm:Module ;
  spin:abstract "true"^^xsd:boolean ;
  rdfs:comment "Modules that import data from a data source on the user's local machine." ;
  rdfs:label "Import from Local"^^xsd:string ;
  rdfs:subClassOf sml:ImportModules ;
.
sml:ImportFromRemoteModules
  rdf:type sm:Module ;
  spin:abstract "true"^^xsd:boolean ;
  rdfs:label "Import from Remote"^^xsd:string ;
  rdfs:subClassOf sml:ImportModules ;
.
sml:ImportFromVariousModules
  rdf:type sm:Module ;
  spin:abstract "true"^^xsd:boolean ;
  rdfs:label "Import from Various"^^xsd:string ;
  rdfs:subClassOf sml:ImportModules ;
.
sml:ImportModules
  rdf:type sm:Module ;
  spin:abstract "true"^^xsd:boolean ;
  composite:index "0"^^xsd:int ;
  rdfs:comment "Modules that import information from some data source. Examples include modules to load files, to get XML from web sources and to take user input." ;
  rdfs:label "Import"^^xsd:string ;
  rdfs:subClassOf sm:Modules ;
.
sml:ImportRDFFromURL
  rdf:type sm:Module ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate sml:password ;
      spl:valueType xsd:string ;
      rdfs:comment "Password for basic authentication, if specified this module will make a BASIC auth HTTP call to the server"^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate sml:serialization ;
      spl:valueType sml:RDFSerialization ;
      rdfs:comment "The serialization type expected from the server. Defaults to RDF/XML if not specified."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate sml:userName ;
      spl:valueType xsd:string ;
      rdfs:comment "User name for BASIC Authentication, if specified this module will make a BASIC auth HTTP call to the server"^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sml:url ;
      rdfs:comment "The URL of the RDF source. May contain variable bindings such as {?varName}."^^xsd:string ;
    ] ;
  rdfs:comment "Gets RDF data from a given URL. The URL may just point to an RDF file on the web, or call a web service with REST-style parameters to receive RDF back. No other format beside RDF/XML or Turtle is supported by this module - use sml:ImportRDFFromWorkspace for other file types."^^xsd:string ;
  rdfs:label "Import RDF from URL"^^xsd:string ;
  rdfs:subClassOf sml:ImportFromRemoteModules ;
.
sml:ImportRDFFromWorkspace
  rdf:type sm:Module ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:defaultValue "false"^^xsd:boolean ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate sml:ignoreImports ;
      spl:valueType xsd:boolean ;
      rdfs:comment "Indicates whether owl:imports shall be ignored. If false, then the union of the base graph plus its (transitive) imports will be returned."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate sml:baseURI ;
      spl:valueType xsd:string ;
      rdfs:comment "The (optional) base URI of the model to open. Either this baseURI must be specified or the sourceFilePath. If both are present then the baseURI has priority."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate sml:sourceFilePath ;
      spl:valueType xsd:string ;
      rdfs:comment "An (optional) file path pointing to the file that shall be opened. The system will look up the base URI of that file and then open that base URI. This means that if the workspace contains multiple copies of that base URI then it may actually load a different file than the one specified here (it will always use the primary file)."^^xsd:string ;
    ] ;
  rdfs:comment "Loads an RDF file from the workspace, based on its base URI (or a path to the file). If the file is already open, it will reuse the currently open model (including any changes that it has compared to the persistent version). The system will use which ever physical file has been registered for the given base URI.  This is the recommended module to load any file type supported by TopBraid, including file serializations (Turtle, RDF/XML and N-TRIPLE), data connectors, XML files (Semantic XML), Excel .xls or .xlsx files (Semantic Tables), etc.  If the file being opened is a file, the file is loaded into memory.  If it is a data connector (RDF or relational back-end), the data source is opened, but no data is loaded into memory. The output graph of this module is the loaded graph only, i.e. other input modules are not passed on."^^xsd:string ;
  rdfs:label "Import RDF from workspace"^^xsd:string ;
  rdfs:subClassOf sml:ImportFromLocalModules ;
.
sml:ImportSystemTriples
  rdf:type sm:Module ;
  rdfs:comment "Imports the RDF Schema and OWL system triples, including the definitions of owl:Class, rdf:type, rdfs:label, rdfs:seeAlso etc. An example use case where this is needed is if you want to query for the rdfs:label of any property including system properties. Another use case is if you want to walk the class hierarchy (using rdfs:subClassOf) including metaclasses and other system classes."^^xsd:string ;
  rdfs:label "Import system triples"^^xsd:string ;
  rdfs:subClassOf sml:ImportFromVariousModules ;
.
sml:ImportTextFile
  rdf:type sm:Module ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:defaultValue "text"^^xsd:string ;
      spl:predicate sm:outputVariable ;
      spl:valueType xsd:string ;
      rdfs:comment "The name of the variable that will contain the text of the file as an xsd:string literal. Default: text."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sml:sourceFilePath ;
      spl:valueType xsd:string ;
      rdfs:comment "The path to a text file. The path can be relative to the current script's folder (e.g., myFolder/test.txt) or absolute to the workspace root /myProject/myFolder/test.txt."^^xsd:string ;
    ] ;
  rdfs:comment "Imports a text file into the xsd:string variable sm:outputVariable." ;
  rdfs:label "Import text file"^^xsd:string ;
  rdfs:subClassOf sml:ImportFromLocalModules ;
.
sml:ImportTextFromURL
  rdf:type sm:Module ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:defaultValue "text"^^xsd:string ;
      spl:predicate sm:outputVariable ;
      spl:valueType xsd:string ;
      rdfs:comment "The output variable to contain the text."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate sml:password ;
      spl:valueType xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate sml:userName ;
      spl:valueType xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sml:url ;
      spl:valueType xsd:string ;
      rdfs:comment "The URL to load from."^^xsd:string ;
    ] ;
  rdfs:comment "Imports a text stream from a URL and writes the result string into a given output variable. Among others, this module can be used to read JSON from REST-based web services."^^xsd:string ;
  rdfs:label "Import text from URL"^^xsd:string ;
  rdfs:subClassOf sml:ImportFromRemoteModules ;
.
sml:ImportXMLFile
  rdf:type sm:Module ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:defaultValue "false"^^xsd:boolean ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate sml:ignoreDoctype ;
      spl:valueType xsd:boolean ;
      rdfs:comment "An (optional) indicator to ignore the XML document type.  This will allow for opening documents offline where the DTD or schema may not be available."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:defaultValue "xml"^^xsd:string ;
      spl:predicate sm:outputVariable ;
      spl:valueType xsd:string ;
      rdfs:comment "The name of the variable containing the XML data. Default: xml."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sml:sourceFilePath ;
      spl:valueType xsd:string ;
      rdfs:comment "The path to the XML file in the workspace. The path can be relative to the current script's folder (e.g., myFolder/test.xml) or absolute to the workspace root /myProject/myFolder/test.xml."^^xsd:string ;
    ] ;
  rdfs:comment "Loads an XML file, specified by a file path and binds the resulting document as an XML DOM tree to the specified output variable. This module is often the starting point of XML processing steps such as XSLT transformations or XPath queries."^^xsd:string ;
  rdfs:label "Import XML file"^^xsd:string ;
  rdfs:seeAlso sml:ExportToXMLFile ;
  rdfs:subClassOf sml:ImportFromLocalModules ;
.
sml:ImportXMLFromURL
  rdf:type sm:Module ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:defaultValue "false"^^xsd:boolean ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate sml:ignoreDoctype ;
      spl:valueType xsd:boolean ;
      rdfs:comment "An (optional) indicator to ignore the XML document type.  This will allow for opening documents where the DTD or schema may not be available."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:defaultValue "xml" ;
      spl:predicate sm:outputVariable ;
      rdfs:comment "The output variable that will hold the loaded XML. Default: xml."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate sml:password ;
      spl:valueType xsd:string ;
      rdfs:comment "The password if using BASIC authentication. If specified this module will attempt to make an HTTP basic auth call before pulling the XML from the source. Leave empty if calling a server without authentication."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate sml:userName ;
      spl:valueType xsd:string ;
      rdfs:comment "The username if using BASIC authentication. If specified this module will attempt to make an HTTP basic auth call before pulling the XML from the source. Leave empty if calling a server without authentication."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sml:url ;
      rdfs:comment "The URL to the XML file. May contain variables such as {?varName}."^^xsd:string ;
    ] ;
  rdfs:comment "Gets XML from a given URL and binds the resulting XML document to a specified output variable. Note that this could either be used to load static XML files from the web, or to call web services that return XML." ;
  rdfs:label "Import XML from URL"^^xsd:string ;
  rdfs:subClassOf sml:ImportFromRemoteModules ;
.
sml:IterateOverSelect
  rdf:type sm:Module ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate sml:iterationVariable ;
      spl:valueType xsd:string ;
      rdfs:comment "The name of a variable which will contain the iteration index in each loop, starting with 0."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate sml:maxThreadCount ;
      spl:valueType xsd:integer ;
      rdfs:comment "Can be used to have the engine execute multiple iterations in parallel threads. The values should be between 2 and a reasonable max value such as 10. If set > 1, the engine will spawn off a new thread for each iteration. Note that some features of SPARQLMotion may not be available in this mode, and that care should be taken when using this feature. In particular, sml:ImportCurrentRDF (when used from TBE) will not work."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Attribute ;
      spl:maxCount 1 ;
      spl:minCount 1 ;
      spl:predicate sm:body ;
      rdfs:comment "The body of the iteration loop."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Attribute ;
      spl:maxCount 1 ;
      spl:minCount 1 ;
      spl:predicate sml:selectQuery ;
      rdfs:comment "A SPARQL Select query that determines the variable bindings for the body in each iteration."^^xsd:string ;
    ] ;
  rdfs:comment """Repeats a given sub-script for each matching result set for the SPARQL Select query in the module's selectQuery property.

The start of the sub-script is specified by the body property. There can only be one body property that invokes a single sub-script.  The sub-script must have one target module -- that is, the sub-script cannot have multiple termination points.

The input RDF for each iteration is the same as the input of the iteration module itself. The result variables of the Select query will be bound inside the body in each iteration of the sub-script. Also, if the sml:IterateOverSelect module itself receives input variable bindings, and the value of these variables are changed inside the body sub-script (e.g. using sml:AppendText or sml:BindLiteralVariable), then the end value of each iteration will be used in the sub-script itself, and thus also passed into the next iteration's body. This allows scripts to incrementally modify variables.  The property sml:iterationVariable can be used to name a variable that will keep an iteration count.

The result of this module are the accumulated triples from the end node of the body sub-script. No internal variable bindings of the body will be used outside of the body, unless they have had values before (see above).

In many cases, a better alternative to creating \"loops\" is to use SPARQL directly, and embed some of the control logic into the WHERE clause, possibly through a CONSTRUCT or UPDATE query.

It is possible to run the iterations in separate threads, e.g. to reduce the amount of time spent waiting on external network resources. This mode, activated by setting sml:maxThreadCount > 2, has some limitations (see description of sml:maxThreadCount) and should be considered by experienced users only."""^^xsd:string ;
  rdfs:label "Iterate over select"^^xsd:string ;
  rdfs:subClassOf sml:ControlFlowModules ;
.
sml:IterateWhile
  rdf:type sm:Module ;
  spin:constraint [
      rdf:type spl:Attribute ;
      spl:maxCount 1 ;
      spl:minCount 1 ;
      spl:predicate sm:body ;
      rdfs:comment "The start of the script that shall be executed as body in each iteration. The body must end with a single target module."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Attribute ;
      spl:maxCount 1 ;
      spl:minCount 1 ;
      spl:predicate sml:askQuery ;
      rdfs:comment "An ASK query that is executed prior to each iteration. If the query returns false, the iteration stops and the most recent result graph will be returned."^^xsd:string ;
    ] ;
  rdfs:comment "Repeats a sub-script (specified as body) as long as a SPARQL ASK query returns true. The output of each iteration is the input to the next. The output of the whole module is the result of the last iteration. No variable bindings are passed into or out of the body." ;
  rdfs:label "Iterate while"^^xsd:string ;
  rdfs:subClassOf sml:ControlFlowModules ;
.
sml:JSONLD
  rdf:type sml:RDFSerialization ;
  rdfs:label "JSON-LD"^^xsd:string ;
.
sml:Merge
  rdf:type sm:Module ;
  rdfs:comment "This module type can be used to merge the variables and RDF triples from multiple input modules. The same is done by any other SPARQLMotion script that has multiple input modules. So while the sml:Merge module basically does not do anything at all, it can be useful to create a clean structure in your script, particularly if you have a case when you want to merge multiple graphs and then have multiple outgoing sm:next links from the merged graph."^^xsd:string ;
  rdfs:label "Merge"^^xsd:string ;
  rdfs:subClassOf sml:ControlFlowModules ;
.
sml:ModifyPrefixes
  rdf:type sm:Module ;
  spin:constraint [
      rdf:type spl:Attribute ;
      spl:minCount "0"^^xsd:int ;
      spl:predicate sml:addedPrefix ;
      rdfs:comment "Namespaces to add, in the format \"prefix namespace\", i.e. the prefix must be followed by a space. Example: \"my http://my.com#\"."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Attribute ;
      spl:minCount "0"^^xsd:int ;
      spl:predicate sml:deletedPrefix ;
      rdfs:comment "The prefix(es) to delete, e.g. \"my\"."^^xsd:string ;
    ] ;
  rdfs:comment "Can be used to add or delete namespace prefix declarations from the input RDF stream so that these new prefixes are visible down stream of this module." ;
  rdfs:label "Modify prefixes"^^xsd:string ;
  rdfs:subClassOf sml:RDFProcessingModules ;
.
sml:N3
  rdf:type sml:RDFSerialization ;
  rdfs:comment "The N3 serialization format. In TopBraid this is only supported as the equivalent of Turtle and may be deleted in future versions."^^xsd:string ;
  rdfs:label "N3"^^xsd:string ;
.
sml:NTriple
  rdf:type sml:RDFSerialization ;
  rdfs:label "NTriple"^^xsd:string ;
.
sml:PerformUpdate
  rdf:type sm:Module ;
  spin:constraint [
      rdf:type spl:Attribute ;
      spl:maxCount "1"^^xsd:int ;
      spl:minCount "1"^^xsd:int ;
      spl:predicate sml:updateQuery ;
      spl:valueType <http://spinrdf.org/sp#Update> ;
      rdfs:comment "The SPARQL 1.1 UPDATE request to perform.  Only one instance of this property will be executed."^^xsd:string ;
    ] ;
  rdfs:comment """Performs a SPARQL UPDATE call to insert and/or delete triples.  This module differs from sml:ApplyConstruct (and other module types) by making persistent changes when the script runs.  Therefore this module should be used carefully.

The default graph of the WHERE clause is the input graph of the module, i.e. the result of its predecessors. However, these cannot be modified using INSERT or DELETE. Instead, a named graph needs to be provided there, e.g. using the GRAPH keyword in the INSERT or DELETE clauses.

Only one instance of sml:updateQuery will be executed.  For multiple SPARQL UPDATE statements use multiple PerformUpdate instances.

EVN/RDM users note that performing an update on a graph under teamwork control (urn:x-evn-...) does not execute EVN-specific side effects: no edit rules will fire and no change history entry may be created. You should always use ui:update in conjunction with sml:CreateSWPDocument to modify such graphs."""^^xsd:string ;
  rdfs:label "Perform update"^^xsd:string ;
  rdfs:subClassOf sml:RDFProcessingModules ;
.
sml:ProcessingModules
  rdf:type sm:Module ;
  spin:abstract "true"^^xsd:boolean ;
  composite:index "1"^^xsd:int ;
  rdfs:comment "Modules that process data, e.g. to transform, filter and map it." ;
  rdfs:label "Processing"^^xsd:string ;
  rdfs:subClassOf sm:Modules ;
.
sml:RDFProcessingModules
  rdf:type sm:Module ;
  spin:abstract "true"^^xsd:boolean ;
  rdfs:label "RDF Processing"^^xsd:string ;
  rdfs:subClassOf sml:ProcessingModules ;
.
sml:RDFSerialization
  rdf:type rdfs:Class ;
  rdfs:comment "The various serialization formats of RDF/OWL files, including RDF/XML and Turtle."^^xsd:string ;
  rdfs:label "RDF Serialization"^^xsd:string ;
  rdfs:subClassOf sm:ValueType ;
.
sml:RDFXML
  rdf:type sml:RDFSerialization ;
  rdfs:label "RDF/XML"^^xsd:string ;
.
sml:RDFXMLAbbrev
  rdf:type sml:RDFSerialization ;
  rdfs:label "RDF/XML-ABBREV"^^xsd:string ;
.
sml:RenameFile
  rdf:type sm:Module ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sml:filePath ;
      spl:valueType xsd:string ;
      rdfs:comment "The path to the file that shall be renamed."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sml:newFileName ;
      spl:valueType xsd:string ;
      rdfs:comment "The new name of the file (excluding the path)."^^xsd:string ;
    ] ;
  rdfs:label "Rename file"^^xsd:string ;
  rdfs:subClassOf sml:FileProcessingModules ;
.
sml:RenameResources
  rdf:type sm:Module ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sml:selectQuery ;
      spl:valueType <http://spinrdf.org/sp#Select> ;
      rdfs:comment "A SELECT query with two result variables, \"new\" and \"old\"."^^xsd:string ;
    ] ;
  rdfs:comment """\"Renames\" a given set of resources so that all the triples they appear in are changed to a use a different URI to downstream modules. Old and new resources are specified by a SELECT query that has two result variables: \"old\" (the resources to rename) and \"new\" to specify a new URI (either as a literal or URI resource).

Note that this module does not change the actual input graph, but only installs a filter above it. This filter may slow down succeeding operations, and you may want to \"assert\" the new graph (e.g., with a sml:ApplyConstruct) following this module."""^^xsd:string ;
  rdfs:label "Rename resources"^^xsd:string ;
  rdfs:subClassOf sml:RDFProcessingModules ;
.
sml:ResetSPINCaches
  rdf:type sm:Module ;
  rdfs:comment "Clears any cached results from SPIN functions marked as spin:cachable. This can be used to reset the cache after \"background data\" has been changed by a script. If such updates only happen periodically, spin:cachable can improve overall performance."^^xsd:string ;
  rdfs:label "Reset SPIN caches"^^xsd:string ;
  rdfs:subClassOf sml:ControlFlowModules ;
.
sml:ReturnNode
  rdf:type sm:Module ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sml:result ;
      rdfs:comment "the result, usually passed in from a previous module"^^xsd:string ;
    ] ;
  rdfs:comment "Returns an RDF node as a result of a script. This module is typically used as exit point of a user-defined SPIN function and web service. The sm:returnModule of the function will point to this."^^xsd:string ;
  rdfs:label "Return node"^^xsd:string ;
  rdfs:subClassOf sml:ExportToRemoteModules ;
.
sml:ReturnRDF
  rdf:type sm:Module ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:defaultValue sml:RDFXML ;
      spl:predicate sml:serialization ;
      spl:valueType sm:ValueType ;
      rdfs:comment "The serialization format - must be sml:JSONLD, sml:RDFXML or sml:Turtle."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate sml:baseURI ;
      spl:valueType xsd:string ;
      rdfs:comment "The base URI of the graph to serialize."^^xsd:string ;
    ] ;
  rdfs:comment "Represents the exit point of a function that returns RDF. The function can be referenced from the outside (e.g., as a web service) by its URI or local name. The RDF triples will be serialized into Turtle, JSON-LD or RDF/XML."^^xsd:string ;
  rdfs:label "Return RDF"^^xsd:string ;
  rdfs:subClassOf sml:ExportToRemoteModules ;
.
sml:ReturnSPARQLResults
  rdf:type sm:Module ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:defaultValue sm:XML ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate sml:serialization ;
      spl:valueType sm:ValueType ;
      rdfs:comment "the serialization format such as XML or JSON"^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Attribute ;
      spl:maxCount 1 ;
      spl:minCount 1 ;
      spl:predicate sml:selectQuery ;
      rdfs:comment "The SELECT query to execute."^^xsd:string ;
    ] ;
  rdfs:comment "Runs a SPARQL Select query and returns its result in the standard SPARQL output formats XML, JSON, CSV or TSV."^^xsd:string ;
  rdfs:label "Return SPARQL results"^^xsd:string ;
  rdfs:subClassOf sml:ExportToRemoteModules ;
.
sml:ReturnSWPDocument
  rdf:type sm:Module ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate sml:mimeType ;
      spl:valueType xsd:string ;
      rdfs:comment "Overrides the default mime type returned by the UISPIN engine."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate sml:snippet ;
      spl:valueType xsd:boolean ;
      rdfs:comment "True to only create a UISPIN snippet, e.g. without head/body."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sml:view ;
      spl:valueType <http://uispin.org/ui#Node> ;
      rdfs:comment "A UISPIN document to render. This document may reference the bound variables of this module."^^xsd:string ;
    ] ;
  rdfs:comment """Creates an SWP document using the current variable bindings and returns the resulting document as HTML, XML, SVG or text to the caller of the web service.

Note that in order to insert a SWP view for a given resource (using ui:instanceView etc), you can use the snippet <ui:resourceView ui:resource=\"{= ?varName }\" />.

Also note that in order to use HTML or SVG tags in the sml:view, you will need to import the html.ttl or svg.ttl from the SWP ontologies into the script."""^^xsd:string ;
  rdfs:label "Return SWP document"^^xsd:string ;
  rdfs:subClassOf sml:ExportToRemoteModules ;
.
sml:ReturnText
  rdf:type sm:Module ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:defaultValue "text"^^xsd:string ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate sml:mimeType ;
      rdfs:comment "The (optional) mime type of the result stream."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate sml:text ;
      rdfs:comment "The text that shall be returned."^^xsd:string ;
    ] ;
  rdfs:comment "Represents the exit point of a function that returns text (mimetype: text). The function can be referenced from the outside (e.g., as a web service) by its URI or local name. When called from TBE, the resulting text will be displayed to the user in a pop-up dialog."^^xsd:string ;
  rdfs:label "Return text"^^xsd:string ;
  rdfs:subClassOf sml:ExportToRemoteModules ;
.
sml:ReturnUISPINDocument
  rdf:type sm:Module ;
  rdf:type owl:DeprecatedClass ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate sml:mimeType ;
      spl:valueType xsd:string ;
      rdfs:comment "Overrides the default mime type returned by the UISPIN engine."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate sml:snippet ;
      spl:valueType xsd:boolean ;
      rdfs:comment "True to only create a UISPIN snippet, e.g. without head/body."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sml:view ;
      spl:valueType <http://uispin.org/ui#Node> ;
      rdfs:comment "A UISPIN document to render. This document may reference the bound variables of this module."^^xsd:string ;
    ] ;
  rdfs:comment "Deprecated: use sml:ReturnSWPDocument instead."^^xsd:string ;
  rdfs:label "Return UISPIN document"^^xsd:string ;
  rdfs:subClassOf sml:ExportToRemoteModules ;
.
sml:ReturnXML
  rdf:type sm:Module ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:defaultValue "text/xml"^^xsd:string ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate sml:mimeType ;
      rdfs:comment "The (optional) mime type of the result stream."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sml:xml ;
      rdfs:comment "The XML document that shall be returned."^^xsd:string ;
    ] ;
  rdfs:comment "Represents the exit point of a function that returns XML. The function can be referenced from the outside (e.g., as a web service) by its URI or local name." ;
  rdfs:label "Return XML"^^xsd:string ;
  rdfs:subClassOf sml:ExportToRemoteModules ;
.
sml:SerializeSPARQLResults
  rdf:type sm:Module ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:defaultValue sm:XML ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate sml:serialization ;
      spl:valueType sm:ValueType ;
      rdfs:comment "The serialization format."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:defaultValue "text"^^xsd:string ;
      spl:predicate sm:outputVariable ;
      spl:valueType xsd:string ;
      rdfs:comment "The name of the output variable that will contain the result."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sml:selectQuery ;
      spl:valueType <http://spinrdf.org/sp#Select> ;
      rdfs:comment "The SELECT query to execute."^^xsd:string ;
    ] ;
  rdfs:comment "Executes a SPARQL SELECT query and serializes its result to either XML or JSON format."^^xsd:string ;
  rdfs:label "Serialize SPARQLResults"^^xsd:string ;
  rdfs:subClassOf sml:TextProcessingModules ;
.
sml:TextProcessingModules
  rdf:type sm:Module ;
  spin:abstract "true"^^xsd:boolean ;
  rdfs:label "Text Processing"^^xsd:string ;
  rdfs:subClassOf sml:ProcessingModules ;
.
sml:Turtle
  rdf:type sml:RDFSerialization ;
  rdfs:label "Turtle"^^xsd:string ;
.
sml:ValidateXMLAgainstXSD
  rdf:type sm:Module ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sml:schemaFilePath ;
      spl:valueType xsd:string ;
      rdfs:comment "The path to an XSD file. The path can be relative to the current script's folder (e.g., myFolder/test.xsd) or absolute to the workspace root /myProject/myFolder/test.xsd."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sml:xml ;
      rdfs:comment "The XML document that shall be validated. If this is represented as a string, then the errors will contain line numbers. Note that the output of modules such as sml:ImportXMLFromFile is not a string but an XML DOM, producing no line numbers."^^xsd:string ;
    ] ;
  rdfs:comment "Validates an existing XML document against a given XML Schema. The XML Schema must be present in the workspace. The output of this module is a new graph containing instances of sxml:XSDValidationError or sxml:XSDValidationWarning. The rdfs:labels of those will contain more information on the error."^^xsd:string ;
  rdfs:label "Validate XML against XSD"^^xsd:string ;
  rdfs:subClassOf sml:XMLProcessingModules ;
.
sml:XMLProcessingModules
  rdf:type sm:Module ;
  spin:abstract "true"^^xsd:boolean ;
  rdfs:label "XML Processing"^^xsd:string ;
  rdfs:subClassOf sml:ProcessingModules ;
.
sml:addedPrefix
  rdf:type rdf:Property ;
  rdfs:label "addedPrefix"^^xsd:string ;
  rdfs:range xsd:string ;
.
sml:askQuery
  rdf:type rdf:Property ;
  rdfs:label "askQuery"^^xsd:string ;
  rdfs:range <http://spinrdf.org/sp#Ask> ;
  rdfs:subPropertyOf spin:query ;
.
sml:baseURI
  rdf:type rdf:Property ;
  rdfs:comment "The base URI of an RDF model." ;
  rdfs:label "baseURI"^^xsd:string ;
  rdfs:range xsd:string ;
.
sml:bindVariables
  rdf:type rdf:Property ;
  rdfs:label "bind variables"^^xsd:string ;
  rdfs:range xsd:boolean ;
.
sml:buttonLabel
  rdf:type rdf:Property ;
  rdfs:label "button label"^^xsd:string ;
  rdfs:range xsd:string ;
.
sml:cached
  rdf:type rdf:Property ;
  rdfs:label "cached"^^xsd:string ;
  rdfs:range xsd:boolean ;
.
sml:cellQuery
  rdf:type rdf:Property ;
  rdfs:label "cellQuery"^^xsd:string ;
  rdfs:range <http://spinrdf.org/sp#Select> ;
  rdfs:subPropertyOf spin:query ;
.
sml:class
  rdf:type rdf:Property ;
  rdfs:label "class"^^xsd:string ;
  rdfs:range rdfs:Class ;
.
sml:className
  rdf:type rdf:Property ;
  rdfs:label "className"^^xsd:string ;
  rdfs:range xsd:string ;
.
sml:columnQuery
  rdf:type rdf:Property ;
  rdfs:label "columnQuery"^^xsd:string ;
  rdfs:range <http://spinrdf.org/sp#Select> ;
  rdfs:subPropertyOf spin:query ;
.
sml:constructQuery
  rdf:type rdf:Property ;
  rdfs:label "constructQuery"^^xsd:string ;
  rdfs:range <http://spinrdf.org/sp#Construct> ;
  rdfs:subPropertyOf spin:query ;
.
sml:content
  rdf:type rdf:Property ;
  rdfs:label "content"^^xsd:string ;
.
sml:contentType
  rdf:type rdf:Property ;
  rdfs:label "content type"^^xsd:string ;
.
sml:dataPath
  rdf:type rdf:Property ;
  rdfs:label "data path"^^xsd:string ;
.
sml:databaseType
  rdf:type rdf:Property ;
  rdfs:label "database type"^^xsd:string ;
  rdfs:range sml:DatabaseType ;
.
sml:datatype
  rdf:type rdf:Property ;
  rdfs:label "datatype"^^xsd:string ;
  rdfs:range rdfs:Datatype ;
.
sml:deletedPrefix
  rdf:type rdf:Property ;
  rdfs:label "deletedPrefix"^^xsd:string ;
  rdfs:range xsd:string ;
.
sml:encoding
  rdf:type rdf:Property ;
  rdfs:label "encoding"^^xsd:string ;
  rdfs:range xsd:string ;
.
sml:filePath
  rdf:type rdf:Property ;
  rdfs:label "file path"^^xsd:string ;
  rdfs:range xsd:string ;
.
sml:filterGraph
  rdf:type rdf:Property ;
  rdfs:comment "Links a filter module with a predecessor module to mark the predecessor module graph to be used for filtering in the filter module."^^xsd:string ;
  rdfs:label "filterGraph"^^xsd:string ;
  rdfs:range spin:Modules ;
.
sml:flatten
  rdf:type rdf:Property ;
  rdfs:label "flatten"^^xsd:string ;
.
sml:graphName
  rdf:type rdf:Property ;
  rdfs:label "graph name"^^xsd:string ;
  rdfs:range xsd:string ;
.
sml:hidden
  rdf:type rdf:Property ;
  rdfs:label "hidden"^^xsd:string ;
  rdfs:range xsd:boolean ;
.
sml:ignoreDoctype
  rdf:type rdf:Property ;
  rdfs:label "ignore document type"^^xsd:string ;
  rdfs:range xsd:boolean ;
.
sml:ignoreImports
  rdf:type rdf:Property ;
  rdfs:label "ignore imports"^^xsd:string ;
  rdfs:range xsd:boolean ;
.
sml:importToInputGraph
  rdf:type rdf:Property ;
  rdfs:label "import to input graph"^^xsd:string ;
  rdfs:range xsd:boolean ;
.
sml:inferencingMode
  rdf:type rdf:Property ;
  rdfs:label "inferencingMode"^^xsd:string ;
.
sml:inputVariable
  rdf:type rdf:Property ;
  rdfs:label "input variable"^^xsd:string ;
  rdfs:range xsd:string ;
.
sml:instancePattern
  rdf:type rdf:Property ;
  rdfs:label "instancePattern"^^xsd:string ;
  rdfs:range xsd:string ;
.
sml:iterationVariable
  rdf:type rdf:Property ;
  rdfs:comment "The name of a variable that shall contain the iteration index in a loop, starting at zero."^^xsd:string ;
  rdfs:label "iteration variable"^^xsd:string ;
  rdfs:range xsd:string ;
.
sml:javaClass
  rdf:type rdf:Property ;
  rdfs:label "java class"^^xsd:string ;
.
sml:jmsConnectionFactory
  rdf:type rdf:Property ;
.
sml:jmsDestination
  rdf:type rdf:Property ;
  rdfs:comment "The name of the JMS queue to send the message to." ;
  rdfs:label "jmssubject"^^xsd:string ;
  rdfs:range xsd:string ;
.
sml:loadBodies
  rdf:type rdf:Property ;
  rdfs:label "loadBodies"^^xsd:string ;
  rdfs:range xsd:boolean ;
.
sml:maxThreadCount
  rdf:type rdf:Property ;
  rdfs:label "max thread count"^^xsd:string ;
.
sml:mimeType
  rdf:type rdf:Property ;
  rdfs:comment "(Reserved for future use.)" ;
  rdfs:label "mimeType"^^xsd:string ;
  rdfs:range xsd:string ;
.
sml:modelName
  rdf:type rdf:Property ;
  rdfs:label "modelName"^^xsd:string ;
  rdfs:range xsd:string ;
.
sml:needsTidy
  rdf:type rdf:Property ;
  rdfs:label "needs tidy"^^xsd:string ;
.
sml:newFileName
  rdf:type rdf:Property ;
  rdfs:label "new file name"^^xsd:string ;
  rdfs:range xsd:string ;
.
sml:newFilePath
  rdf:type rdf:Property ;
  rdfs:label "new file path"^^xsd:string ;
  rdfs:range xsd:string ;
.
sml:newGraph
  rdf:type rdf:Property ;
  rdfs:label "new graph"^^xsd:string ;
  rdfs:range spin:Modules ;
.
sml:oldFilePath
  rdf:type rdf:Property ;
  rdfs:label "old file path"^^xsd:string ;
  rdfs:range xsd:string ;
.
sml:oldGraph
  rdf:type rdf:Property ;
  rdfs:label "old graph"^^xsd:string ;
  rdfs:range spin:Modules ;
.
sml:onCommit
  rdf:type rdf:Property ;
  rdfs:label "on commit"^^xsd:string ;
  rdfs:range xsd:boolean ;
.
sml:password
  rdf:type rdf:Property ;
  rdfs:label "password"^^xsd:string ;
  rdfs:range xsd:string ;
.
sml:path
  rdf:type rdf:Property ;
  rdfs:comment "Can be used to represent path expressions such as /INBOX/TBC-MailingList" ;
  rdfs:label "path"^^xsd:string ;
  rdfs:range xsd:string ;
.
sml:predicate
  rdf:type rdf:Property ;
  rdfs:label "predicate"^^xsd:string ;
  rdfs:range rdf:Property ;
.
sml:propertyPrefix
  rdf:type rdf:Property ;
  rdfs:label "propertyPrefix"^^xsd:string ;
  rdfs:range xsd:string ;
.
sml:replace
  rdf:type rdf:Property ;
  rdfs:comment "Specifies whether a module shall overwrite all triples from its predecessors. If set to true (default is false), then the triples from the predecessors shall not be passed through." ;
  rdfs:label "replace"^^xsd:string ;
  rdfs:range xsd:boolean ;
.
sml:result
  rdf:type rdf:Property ;
  rdfs:label "result"^^xsd:string ;
.
sml:rowQuery
  rdf:type rdf:Property ;
  rdfs:label "rowQuery"^^xsd:string ;
  rdfs:range <http://spinrdf.org/sp#Select> ;
  rdfs:subPropertyOf spin:query ;
.
sml:ruleBaseName
  rdf:type rdf:Property ;
  rdfs:label "ruleBaseName"^^xsd:string ;
  rdfs:range xsd:string ;
.
sml:schemaFilePath
  rdf:type rdf:Property ;
  rdfs:label "schema file path"^^xsd:string ;
  rdfs:range xsd:string ;
.
sml:schemaNamespace
  rdf:type rdf:Property ;
  rdfs:label "schemaNamespace"^^xsd:string ;
  rdfs:range xsd:string ;
.
sml:selectInstanceClass
  rdf:type rdf:Property ;
  rdfs:domain sml:SelectInstance ;
  rdfs:label "selectInstanceClass"^^xsd:string ;
  rdfs:range rdfs:Class ;
.
sml:selectQuery
  rdf:type rdf:Property ;
  rdfs:label "select query"^^xsd:string ;
  rdfs:range <http://spinrdf.org/sp#Select> ;
  rdfs:subPropertyOf spin:query ;
.
sml:selectedResource
  rdf:type rdf:Property ;
  rdfs:comment "The suggested default property to use in conjunction with sml:SelectedResourceArgument." ;
  rdfs:label "selected resource"^^xsd:string ;
.
sml:separator
  rdf:type rdf:Property ;
  rdfs:label "separator"^^xsd:string ;
  rdfs:range xsd:string ;
.
sml:serialization
  rdf:type rdf:Property ;
  rdfs:label "serialization"^^xsd:string ;
  rdfs:range sml:RDFSerialization ;
.
sml:singlePass
  rdf:type rdf:Property ;
  rdfs:label "single pass"^^xsd:string ;
  rdfs:range xsd:boolean ;
.
sml:snippet
  rdf:type rdf:Property ;
  rdfs:label "snippet"^^xsd:string ;
.
sml:sourceFilePath
  rdf:type rdf:Property ;
  rdfs:comment "The path to a file relative in the execution context (workspace). Values can be relative to the currently executing script (e.g., subFolder/file.txt) or absolute to the workspace root (starting with /)." ;
  rdfs:label "sourceFilePath"^^xsd:string ;
  rdfs:range xsd:string ;
.
sml:sql
  rdf:type rdf:Property ;
  rdfs:label "sql"^^xsd:string ;
.
sml:stackTraceVariable
  rdf:type rdf:Property ;
  rdfs:label "stack trace variable"^^xsd:string ;
  rdfs:range xsd:string ;
.
sml:targetFilePath
  rdf:type rdf:Property ;
  rdfs:label "targetFilePath"^^xsd:string ;
  rdfs:range xsd:string ;
.
sml:template
  rdf:type rdf:Property ;
  rdfs:label "template"^^xsd:string ;
  rdfs:range xsd:string ;
.
sml:text
  rdf:type rdf:Property ;
  rdfs:label "text"^^xsd:string ;
  rdfs:range xsd:string ;
.
sml:title
  rdf:type rdf:Property ;
  rdfs:label "title"^^xsd:string ;
  rdfs:range xsd:string ;
.
sml:updateQuery
  rdf:type rdf:Property ;
  rdfs:comment "A SPARQL UPDATE query (can be used to insert or delete triples from a graph)." ;
  rdfs:label "update query"^^xsd:string ;
  rdfs:range <http://spinrdf.org/sp#Update> ;
.
sml:uri
  rdf:type rdf:Property ;
  rdfs:label "uri"^^xsd:string ;
  rdfs:range xsd:string ;
.
sml:url
  rdf:type rdf:Property ;
  rdfs:label "url"^^xsd:string ;
  rdfs:range xsd:string ;
.
sml:useUnderscore
  rdf:type rdf:Property ;
  rdfs:label "useUnderscore"^^xsd:string ;
  rdfs:range xsd:boolean ;
.
sml:useVerbatim
  rdf:type rdf:Property ;
  rdfs:label "useVerbatim"^^xsd:string ;
  rdfs:range xsd:boolean ;
.
sml:userName
  rdf:type rdf:Property ;
  rdfs:label "userName"^^xsd:string ;
  rdfs:range xsd:string ;
.
sml:value
  rdf:type rdf:Property ;
  rdfs:label "value"^^xsd:string ;
.
sml:variable
  rdf:type rdf:Property ;
  rdfs:label "variable"^^xsd:string ;
  rdfs:range xsd:string ;
.
sml:view
  rdf:type rdf:Property ;
  rdfs:label "view"^^xsd:string ;
.
sml:xml
  rdf:type rdf:Property ;
  rdfs:label "xml"^^xsd:string ;
  rdfs:range rdf:XMLLiteral ;
.
sml:xmlType
  rdf:type rdf:Property ;
  rdfs:label "xmlType"^^xsd:string ;
  rdfs:range [] ;
.
sml:xpath
  rdf:type rdf:Property ;
  rdfs:comment "An XPath expression." ;
  rdfs:label "xpath"^^xsd:string ;
  rdfs:range xsd:string ;
.
<http://topbraid.org/sparqlmotionlib-core>
  rdf:type owl:Ontology ;
  rdfs:comment "The library of SPARQLMotion core modules that are available in any SPARQLMotion-compliant engine, including the TopBraid platform and the TopBraid API."^^xsd:string ;
  owl:imports <http://spinrdf.org/spif> ;
  owl:imports <http://spinrdf.org/spr> ;
  owl:imports <http://topbraid.org/sparqlmotion> ;
  owl:imports <http://www.topbraid.org/2007/05/composite.owl> ;
  owl:versionInfo "0.7.0"^^xsd:string ;
.
